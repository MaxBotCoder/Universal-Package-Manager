This document will essentially be the bible for the project explaining what and how everything will be executed.
Hence development for the Universal Package Manager aka U.P.M. will use this as reference material.

The goal is to provide a fast, efficient, secure and reliable way for developers to deploy apps within a sandboxed environment. 
Thus negating the need for developers to choose between supporting one OS very well or supporting many OSs poorly.
We aim to execute this by having the developers of this platform use an immutable blockchain-based repo system to store their code and have it pulled down locally 
onto the user's computer which will then allow said code to be compiled and then executed within a sandboxed environment.

Phase 1: Successfully create a blockchain based repo storing code on an Ethereum testnet (All NON-PROTOTYPE REPOS WILL BE ON THE MAINNET). 
Then proceed to successfully pull down the code to be run locally on my computer (PRIOR TO SANDBOX)
Why?

Goal 1 of phase 1: Extract data from smart contracts.

Goal 3 of phase 1: Have the Universal Package Manager interact with the file system and write to a text file.

Goal 4 of phase 1: Have the Universal Package Manager be capable of differentiating between coding languages.

Goal 5 of phase 1: Have a proper file system with folders separating code that will be updated and replaced and data that will be stored long term like web browser data, game saves, or even text documents.

Goal 6 of phase 1 (Relates to goal 1 of the sandbox): The package manager would allow the sandboxed environment to run the code either by pre-compiling it into an executable format of some kind, or
it might not pre-compile the code. The sandboxed environment's potential ability to interpret the code without pre-compiling has not been set in stone. Hence, whether or not I add this feature is a matter of my choice.

- Ethereum has fairly high gas fees, which means that in order to write to the Ethereum network an individual must pay prior. Thus encouraging developers to think prior to uploading their code
pressuring them to make/upload higher quality code as well as discouraging malicious players from uploading malicious code to the repos. 

Phase 2: Creating a sandboxed environment to run said code from the repos, similar to flatpak applications in which the sandboxed environments will be self-contained, won't mess around with root directories.
The sandbox will initially support Linux & Windows then will later support Mac, etc.. hopefully, the open-source nature of this project will encourage ports of this package manager to various different platforms.

Goal 1 of phase 2: Create a sandboxed environment that can run code from the directories created by the package manager either by interpretation like a browser or via compilation.

Goal 2 of phase 2: Create support for daemons, integrating them with the OS as if they were installed directly, this will allow for features like notifications, alarms various other system alerts or
essential background operations. 

Phase 3: Creating an easy to use GUI to work in unison with the pre-existing terminal interface which will be used. This interface will allow people to add/remove repos as well as download apps, this
gui variant of U.P.M. will be dubbed the Universal App Store. 

Goal 1 of phase 3: Create a simple app displaying system which will show all of the packages available in alphabetical order.

Goal 2 of phase 3: Create a based search system.

Goal 3 of phase 3: Have a category called verified apps, either from trusted repositories made by developers/companies porting and or developing on Universal Package Manager.

Phase 4: Create a simple to use app creation and or enhancing AI which will be trained on code uploaded to our repos or various other sources such as code from robust opensource applications or the AI could be used for the (POSSIBLE) code interpretation system within the sandboxed environment.

NOTE: Perhaps phase 4 could be integrated into Phase 2 (sandboxed environment) by using an AI to read the code, interpret it then execute it?
